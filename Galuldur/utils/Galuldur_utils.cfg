#textdomain wesnoth-Galuldur

#define NEW_LEADER_APPEARS SIDE TYPE X Y ID WML
    # Creates the new leader,
    # Starts ai control for the side and unhides it
    # WML: can be used to set additional unit properties, e.g. set a name
    [unit]
        side={SIDE}
        id={ID}
        type={TYPE}
        x,y={X},{Y}
        generate_name=yes
        canrecruit=yes
        {WML}
    [/unit]

    [modify_side]
        side={SIDE}
        hidden=no
        controller=ai
    [/modify_side]
#enddef

#define MOVE_AND_KILL FILTER X Y
    # MOVE_UNIT to X,Y, and kills it
    {MOVE_UNIT {FILTER} {X} {Y}}
    [kill]
        {FILTER}
    [/kill]
#enddef

#define ANIMALS_SIDE SIDE
    # Set up of the Wolves side
    [side]
        side={SIDE}
        controller=ai
        no_leader = yes

        team_name=Animals
        user_team_name=_"Animals"

        canrecruit=no
        [ai]
            village_value=0
            aggression=0.9
            caution=0.1
        [/ai]

        hidden=yes
    [/side]
#enddef

#define NEW_WOLF SIDE WOLF_MAX X Y
    # Event: New wolf for side {SIDE} at beginning of each turn at {X},{Y} if there are less than {WOLF_MAX}
    [event]
        name=new turn
        first_time_only=no
        {VARIABLE tmp {WOLF_MAX}}
        {VARIABLE_OP tmp add -1}
        [if]
            [have_unit]
                side={SIDE}
                type=Wolf
                count=0-$tmp
            [/have_unit]
            [then]
                {GENERIC_UNIT {SIDE} Wolf {X} {Y}}
            [/then]
        [/if]
        {CLEAR_VARIABLE tmp}
    [/event]
#enddef

#define RANDOM_FOES_SIDE SIDE
    # Random Foes side is required several times
    [side]
        side={SIDE}
        controller=ai
        no_leader=yes

        team_name=Random
        user_team_name=_"Random"

        canrecruit=no
        [ai]
            simple_targeting=yes
            village_value=0
            aggression=0.9
            caution=0.1
        [/ai]

        hidden=yes
    [/side]
#enddef

#define RANDOM_FOES_EVENT SIDE PROBABILITY X_RANGE Y_RANGE
    # Event: At the beginning of the turn, there's a chance of Random Foes unit to appear in the X_RANGE, Y_RANGE area
    #   Closest unoccupied and passable hex will be found
    [event]
        name=new turn
        first_time_only=no
        {RANDOM 0..99}

        [if]
            [variable]
                name=random
                less_than={PROBABILITY}
            [/variable]

            [then]
                [set_variable]
                    name=rand_type
                    rand="Troll,Troll Whelp,Wolf,Wolf Rider,Goblin Knight,Young Ogre,Ogre,Footpad,Thug,Thief,Poacher,Goblin Impaler,Goblin Rouser"
                [/set_variable]
                [set_variable]
                    name=rand_x
                    rand={X_RANGE}
                [/set_variable]
                [set_variable]
                    name=rand_y
                    rand={Y_RANGE}
                [/set_variable]
                # Now make sure that this position is unoccupied and passable
                #   (which will offset the position by one, but since it is random anyway, who cares...)
                {CLOSE_EMPTY_HEX $rand_x $rand_y *^Xm,Wo 1}
                {CLEAR_VARIABLE rand_x}
                {CLEAR_VARIABLE rand_y}
                {GENERIC_UNIT {SIDE} $rand_type $hex_x $hex_y}
                {CAPTURE_FILTERED_VILLAGES_COPY {SIDE} x,y=$hex_x,$hex_y}
                {CLEAR_VARIABLE rand_type}
                {CLEAR_VARIABLE hex_x}
                {CLEAR_VARIABLE hex_y}
            [/then]
        [/if]

        {CLEAR_VARIABLE random}
    [/event]
#enddef

#define BURN_FOREST LOCATION_FILTER
    # Replace forest by burnt forest tiles
    #   LOCATION_FILTER: location filter to be used
    #   A redraw might be required afterward

    # Forest on flats
    [store_locations]
        terrain=Gs^F*,Gg^F*
        [and]
            {LOCATION_FILTER}
        [/and]
        variable=forest_flats
    [/store_locations]
    {FOREACH forest_flats i}
        {MODIFY_TERRAIN Gs^Fdw $forest_flats[$i].x $forest_flats[$i].y}
    {NEXT i}
    {CLEAR_VARIABLE forest_flats}

    # Forest on hills
    [store_locations]
        terrain=Hh^F*
        [and]
            {LOCATION_FILTER}
        [/and]
        variable=forest_hills
    [/store_locations]
    {FOREACH forest_hills i}
        {MODIFY_TERRAIN Hh^Fdw $forest_hills[$i].x $forest_hills[$i].y}
    {NEXT i}
    {CLEAR_VARIABLE forest_hills}
#enddef

#define PASS_OF_HANGARN X Y
    # Event: Pass of Hangarn message
    [event]
        name=moveto
        first_time_only=no
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        {MESSAGE narrator "wesnoth-icon.png" "" _"Pass of Hangarn"}
    [/event]
#enddef

#define BIG_TREE X Y
    # Event: Big tree
    #    X Y: coordinates
    [event]
        name=moveto
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        {MESSAGE unit "" "" _"How can such a big tree survive up here?"}
    [/event]
#enddef

#define ADLEWYS_PASSAGE X Y
    # Event: Adlewys Passage message
    #    X Y: coordinates
    [event]
        name=moveto
        first_time_only=no
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        {MESSAGE narrator "wesnoth-icon.png" "" _"Adlewys Passage"}
    [/event]
#enddef

#define PLEASANT_PASSAGE X Y
    # Event: Pleasant Passage message
    #    X Y: coordinates
    [event]
        name=moveto
        first_time_only=no
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        {MESSAGE narrator "wesnoth-icon.png" "" _"Pleasant Passage
(Never mind the smell)"}
    [/event]
#enddef

#define CLOSE_EMPTY_HEX X Y NOT_TERRAIN STARTING_RADIUS
    # Get the coordinates of an unoccupied hex within STARTING_RADIUS of the input coordinates
    # that is not of terrain type NOT_TERRAIN
    # INPUT: X Y : the coordinates of the hex around which to look
    #        NOT_TERRAIN: the type of terrain that the hex should NOT have
    #        STARTING_RADIUS: at what radius from the center hex we start; this is increased one by one until an empty hex is found
    # Output: hex_x hex_y: return variable of new coordinates

    {VARIABLE r {STARTING_RADIUS}}
    [while]
        [variable]
            name=r
            less_than=99
        [/variable]

        [do]
            [store_locations]
                [and]  # within radius
                    x,y={X},{Y}
                    radius=$r
                [/and]
                [not]  # unoccupied
                    [filter]
                    [/filter]
                [/not]
                [not]  # not of the given type of terrain
                    terrain={NOT_TERRAIN}
                [/not]
                variable=coords
            [/store_locations]

            [if]
                [variable]
                    name=coords.length
                    greater_than=0
                [/variable]

                [then]  # if something was found, break the loop
                    #{FOREACH coords i_c}
                    #{MESSAGE narrator "" "" ($r $i_c $coords.length $coords[$i_c].x $coords[$i_c].y $coords[$i_c].terrain)}
                    #{NEXT i_c}
                    {VARIABLE r 99}
                [/then]

                [else]  # otherwise increase the search radius
                    {VARIABLE_OP r add 1}
                    #{MESSAGE narrator "" "" ($r {NOT_TERRAIN})}
                [/else]
            [/if]
        [/do]
    [/while]
    {CLEAR_VARIABLE r}

    # Now pick one of those hexes randomly
    {VARIABLE i_hex $coords.length}
    {VARIABLE_OP i_hex add -1}
    {RANDOM 0..$i_hex}
    {VARIABLE hex_x $coords[$random].x}
    {VARIABLE hex_y $coords[$random].y}
    #{MESSAGE narrator "" "" (Result: $hex_x $hex_y [$random/$coords.length])}
    {CLEAR_VARIABLE coords}
    {CLEAR_VARIABLE i_hex}
    {CLEAR_VARIABLE random}
#enddef

#define FAR_EMPTY_HEX X Y NOT_TERRAIN STARTING_RADIUS
    # This is almost the same as CLOSE_EMPTY_HEX, except that it return coordinates for
    # a location that is _exactly_ as far away as STARTING_RADIUS (or farther, if none available)
    # Get the coordinates of an unoccupied, hex a given radius away from the input coordinates
    # that is not of terrain type NOT_TERRAIN
    # INPUT: X Y : the coordinates of the hex around which to look
    #        NOT_TERRAIN: the type of terrain that the hex should NOT have
    #        STARTING_RADIUS: at what radius from the center hex we start; this is increased one by one until an empty hex is found
    # Output: hex_x hex_y: return variable of new coordinates

    {VARIABLE r {STARTING_RADIUS}}
    [while]
        [variable]
            name=r
            less_than=99
        [/variable]

        [do]
            {VARIABLE r_minus_1 $r}
            {VARIABLE_OP r_minus_1 add -1}
            [store_locations]
                [and]  # within radius
                    x,y={X},{Y}
                    radius=$r
                [/and]
                [not]  # not within radius
                    x,y={X},{Y}
                    radius=$r_minus_1
                [/not]
                [not]  # unoccupied
                    [filter]
                    [/filter]
                [/not]
                [not]  # not of the given type of terrain
                    terrain={NOT_TERRAIN}
                [/not]
                variable=coords
            [/store_locations]
            [if]
                [variable]
                    name=coords.length
                    greater_than=0
                [/variable]

                [then]  # if something was found, break the loop
                    #{FOREACH coords i_c}
                    #{MESSAGE narrator "" "" ($r $i_c $coords.length $coords[$i_c].x $coords[$i_c].y $coords[$i_c].terrain)}
                    #{NEXT i_c}
                    {VARIABLE r 99}
                [/then]

                [else]  # otherwise increase the search radius
                    {VARIABLE_OP r add 1}
                    #{MESSAGE narrator "" "" ($r {NOT_TERRAIN})}
                [/else]
            [/if]
        [/do]
    [/while]
    {CLEAR_VARIABLE r}
    {CLEAR_VARIABLE r_minus_1}

    # Now pick one of those hexes randomly
    {VARIABLE i_hex $coords.length}
    {VARIABLE_OP i_hex add -1}
    {RANDOM 0..$i_hex}
    {VARIABLE hex_x $coords[$random].x}
    {VARIABLE hex_y $coords[$random].y}
    #{MESSAGE narrator "" "" (Result: $hex_x $hex_y [$random/$coords.length])}
    {CLEAR_VARIABLE coords}
    {CLEAR_VARIABLE i_hex}
    {CLEAR_VARIABLE random}
#enddef

#define NORFINDIL_TROOPS NORFINDIL_X NORFINDIL_Y VADDAN_X VADDAN_Y
    # - NORFINDIL_X NORFINDIL_Y: Starting position for Norfindil
    # - VADDAN_X VADDAN_Y: Starting position for Vaddan

    # Set up the side
    [modify_side]
        side=2
        controller=human
        hidden=no
    [/modify_side]

    # Bring out Norfindil's troops
    {FOREACH Norfindil_troops i}
        #{MESSAGE narrator "" "" ($i+"/"+$Norfindil_troops.length+": "+$Norfindil_troops[$i].id+" "+$Norfindil_troops[$i].type)}

        # Switch to Side 2
        {VARIABLE Norfindil_troops[$i].side 2}
        # Put them into the right location
        [switch]
            variable=Norfindil_troops[$i].id
            [case]
                value=Norfindil
                {VARIABLE Norfindil_troops[$i].x {NORFINDIL_X}}
                {VARIABLE Norfindil_troops[$i].y {NORFINDIL_Y}}
            [/case]
            [case]
                value=Vaddan
                {VARIABLE Norfindil_troops[$i].x {VADDAN_X}}
                {VARIABLE Norfindil_troops[$i].y {VADDAN_Y}}
            [/case]
            [else]
                {VARIABLE Norfindil_troops[$i].x recall}
                {VARIABLE Norfindil_troops[$i].y recall}
            [/else]
        [/switch]
        # Now unstore them
        [unstore_unit]
            variable=Norfindil_troops[$i]
            find_vacant=yes
        [/unstore_unit]
    {NEXT i}
    {CLEAR_VARIABLE Norfindil_troops}

    # Make Norfindil the leader for this part; give Vaddan hero icon
    {MODIFY_UNIT id=Norfindil canrecruit yes}
    {UNMAKE_HERO Norfindil}
    {MAKE_HERO Vaddan}
#enddef

#define OLD_JOURNEY_YELLOW X Y
    # Make an old journey mark on a tracking map
    [image]
        x,y={X},{Y}
        file=dot-yellow.png
        centered=yes
    [/image]
#enddef

#define OLD_BATTLE_YELLOW X Y
    # Make an old battle mark on a tracking map
    [image]
        x,y={X},{Y}
        file=cross-yellow.png
        centered=yes
    [/image]
#enddef

#define OLD_REST_YELLOW X Y
    # Make an old rest mark on a tracking map
    [image]
        x,y={X},{Y}
        file=flag-yellow.png
        centered=yes
    [/image]
#enddef

#define BURN_ON_MOVE_S8_10 SIDES
    # Event: trees get burnt as enemy sides move - Scenarioes 8 & 10
    #   This does not do all the same as in Scen 4 (there is no limit, and no defeat event)
    [event]
        name=moveto
        first_time_only=no
        # If one of the units in the orc sides ...
        [filter]
            side={SIDES}
        [/filter]
        # ... moves onto or within 1 move of an unburnt forest tile, store the respective tiles locations
        {BURN_FOREST (
            x,y=$x1,$y1
            radius=1
        )}
    [/event]
#enddef

#define SOUND SOUND_FILE
    [sound]
        name={SOUND_FILE}
    [/sound]
#enddef

#define DELAY DELAY_TIME
    [delay]
        time={DELAY_TIME}
    [/delay]
#enddef

#define MENU_ELRALITH_CONTROL SIDE
    # Menu items for making Elralith go to a certain location
    # SIDE: the side Eralith is on

    # Set up menu item for making Elralith go somewhere
    {VARIABLE Elralith_goal_set no}
    [store_map_dimensions]  # This might already be stored in the scenario, but that does not matter
        variable=map_dims
    [/store_map_dimensions]
    [set_menu_item]
        id=move_Elralith
        description=_"Make Elralith go here"
        # Only when clicked on a location (excluding the edge of the map)
        [show_if]
            [variable]
                name=x1
                greater_than=0
            [/variable]
            [and]
                [variable]
                    name=x1
                    less_than_equal_to=$map_dims.width
                [/variable]
            [/and]
            [and]
                [variable]
                    name=y1
                    greater_than=0
                [/variable]
            [/and]
            [and]
                [variable]
                    name=y1
                    less_than_equal_to=$map_dims.height
                [/variable]
            [/and]
            [and]
                [variable]
                    name=Elralith_goal_set
                    equals=no
                [/variable]
            [/and]
        [/show_if]
        [command]
            {VARIABLE Elralith_goal_set yes}
            [modify_side]
                side={SIDE}
                [ai]
                    [leader_goal]
                        x,y=$x1,$y1
                    [/leader_goal]
                [/ai]
            [/modify_side]
        [/command]
    [/set_menu_item]

    # Set up second menu item to clear the goal for Elralith
    [set_menu_item]
        id=dont_move_Elralith
        description=_"Let Elralith go wherever he wants"
        [show_if]
            [variable]
                name=Elralith_goal_set
                equals=yes
            [/variable]
        [/show_if]
        [command]
            {VARIABLE Elralith_goal_set no}
            [modify_side]
                side={SIDE}
                [ai]
                    [leader_goal]  # Clear the goal
                    [/leader_goal]
                [/ai]
            [/modify_side]
        [/command]
    [/set_menu_item]
#enddef

#define CLEAR_ELRALITH_MENU
    # This is a separate event, which is triggered at victory
    [event]
        name=victory

        # Disable the menu items used in this scenario - don't know a better way to do this
        [set_menu_item]
            id=move_Elralith
            [show_if]
                [not]
                [/not]
            [/show_if]
        [/set_menu_item]
        [set_menu_item]
            id=dont_move_Elralith
            [show_if]
                [not]
                [/not]
            [/show_if]
        [/set_menu_item]

        {CLEAR_VARIABLE Elralith_goal_set}
        {CLEAR_VARIABLE map_dims}
    [/event]
#enddef

#define CLEAR_FOG_FIXED SIDE X Y RADIUS
    # Same as in standard macros, but with a bug fixed that did not work when
    # there was more than one fog clearer
    # Clears fog in a specific area for the given side. This is to be used only
    # for the duration of an event: always use {UNCLEAR_FOG} (below) before the
    # event exits, or otherwise you'll be left with fake fog clearer units on
    # the map.
    [if]
        [have_unit]
            type=Fog Clearer
        [/have_unit]

        [then]
            [set_variable]
                name=fog_clearer_i
                add=1
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=fog_clearer_i
                value=1
            [/set_variable]
        [/else]
    [/if]

    [unit]
        side={SIDE}
        type=Fog Clearer
        id=fog_clearer_$fog_clearer_i
        x,y={X},{Y}
        max_moves={RADIUS}
    [/unit]

    [store_unit]
        [filter]
            id=fog_clearer_$fog_clearer_i
        [/filter]

        kill=no
        variable=new_fog_clearer
    [/store_unit]

    [hide_unit]
        x,y=$new_fog_clearer.x,$new_fog_clearer.y
    [/hide_unit]

    [redraw]
        side={SIDE}
    [/redraw]

    [clear_variable]
        name=new_fog_clearer
    [/clear_variable]
#enddef

#define UNCLEAR_FOG_FIXED
    # Same as in standard macros, but with a bug fixed that did not work when
    # there was more than one fog clearer
    # Restores fog that was temporarily cleared (check CLEAR_FOG above). Only
    # one UNCLEAR_FOG is required no matter how many times CLEAR_FOG was used.
    [kill]
        type=Fog Clearer
        animate=no
        fire_event=no
    [/kill]

    [clear_variable]
        name=fog_clearer_i
    [/clear_variable]
#enddef

#define PLACE_AND_REMOVE_ITEM HALO X Y DELAY_TIME
    [item]
        x,y={X},{Y}
        halo={HALO}
    [/item]
    {DELAY {DELAY_TIME}}
    [remove_item]
        x,y={X},{Y}
    [/remove_item]
#enddef

#define GALURS_MESSENGER
    {SCROLL_TO 38 11}
    {UNIT 1 "Elvish Rider" 39 15 (id=tmp_rider)}
    {MOVE_UNIT id=tmp_rider 38 11}
    {MESSAGE tmp_rider "" "" _"Wait, $has_staff!  Galur sent me to ..."}
    {MESSAGE Galuldur "" "" _"My father?  He is alive?"}
    {MESSAGE tmp_rider "" "" _"He was the last time I saw him, but we were under heavy attack.  I do not know how long he and his people can hold out.  But anyway, Galur says that you must not use the magical staff to convert an enemy unit.  He didn't explain further, but he said that you would understand what that means.  I must go back now."}
    {MOVE_AND_KILL id=tmp_rider 39 15}
    {VARIABLE messenger_appeared yes}
#enddef

#define S10_SECONDARY_OBJECTIVES
    [objective]
        description= _ "Death of Galuldur"
        condition=lose
    [/objective]
    [objective]
        description= _ "Death of Vaddan"
        condition=lose
    [/objective]
    [objective]
        [show_if]
            [have_unit]
                id=Galur
            [/have_unit]
        [/show_if]
        description= _ "Death of Galur"
        condition=lose
    [/objective]
    [objective]
        [show_if]
            [have_unit]
                id=Galur    # No typo!!!  We know this after Galur appeared, not Norfindil
            [/have_unit]
        [/show_if]
        description= _ "Death of Norfindil"
        condition=lose
    [/objective]
    [objective]
        [show_if]
            [have_unit]
                id=Elralith
            [/have_unit]
        [/show_if]
        description= _ "Death of Elralith"
        condition=lose
    [/objective]
    [objective]
        [show_if]
            [variable]
                name=messenger_appeared
                equals=yes
            [/variable]
        [/show_if]
        description= _ "Enemy unit is converted with Saidenwaxl Staff"
        condition=lose
    [/objective]
    [objective]
        [show_if]
            [have_unit]
                id=Galur
            [/have_unit]
            [not]
                [have_unit]
                    id=Norfindil
                    side=1
                [/have_unit]
            [/not]
        [/show_if]
        description= _ "Unit other than Norfindil is converted with Saidenwaxl Staff"
        condition=lose
    [/objective]
#enddef

#define GALURS_MESSENGER_OBJECTIVES
    [objectives]
        [objective]
            description= _"Figure out what happened.  Defeat all enemy leaders as you go along."
            condition=win
        [/objective]
        {S10_SECONDARY_OBJECTIVES}
    [/objectives]
#enddef

#define FIND_OPPOSITE_HEX X_CENTER Y_CENTER X Y
    # X_CENTER,Y_CENTER: position of the center of the 7 hexes
    # X,Y: position of hex for which the opposite side w.r.t X_CENTER,Y_CENTER is to be found

    # Finding the opposite x position is easy, simply add (X_CENTER-X) to X_CENTER
    {VARIABLE x_opp {X_CENTER}}
    {VARIABLE_OP x_opp sub {X}}  # This is dx = X_CENTER-X
    {VARIABLE_OP x_opp add {X_CENTER}}
    #{MESSAGE narrator "" "" ({X_CENTER} $x_opp)}

    # y is slightly more tricky, because of the hexagonal shape, but there's a neat trick
    #   that saves us from having to build in a lot of if statements
    # Among the adjacent hexes, it is the one with the correct x, and y _different_ from Y
    [store_locations]
        [filter_adjacent_location]
            x,y={X_CENTER},{Y_CENTER}
        [/filter_adjacent_location]
        [and]
            x=$x_opp
        [/and]
        [not]
            y={Y}
        [/not]
        variable=tmp_coords
    [/store_locations]
    #{MESSAGE narrator "" "" ($tmp_coords.length)}

    {VARIABLE y_opp $tmp_coords[0].y}
    #{MESSAGE narrator "" "" ($x_opp $y_opp)}

    {CLEAR_VARIABLE tmp_coords}
#enddef

#define COUNT_UNITS FILTER
    # Count the units that match the filter; returned in variable 'unit_count'
    # FILTER: the unit filter to be matched
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=stored_count_units
        mode=append
    [/store_unit]
    {VARIABLE unit_count $stored_count_units.length}
    {CLEAR_VARIABLE stored_count_units}
#enddef

# ----------------------------------------------
# The following are macros that will be deprecated in 1.9.4
# This is the lazy way to get around that, they are simply copies of the 1.8 macros

#define REDRAW_COPY
    [redraw]
    [/redraw]
#enddef

#define FLOATING_TEXT_COPY FILTER COLOUR_VALUE TEXT
    # Floats the given text above the given unit in the same manner as
    # damage numbers are displayed in combat.  For example when a unit
    # steps on a hidden trap and is dealt 8 damage, let's show this to
    # the player like all other damage is:
    #! {FLOATING_TEXT_COPY x,y=$x1,$y1 255,0,0 "8"}
    [store_unit]
        [filter]
            {FILTER}
        [/filter]

        kill=no
        variable=FLOATING_TEXT_temp
    [/store_unit]

    [unstore_unit]
        variable=FLOATING_TEXT_temp
        find_vacant=no
        red,green,blue={COLOUR_VALUE}
        text={TEXT}
    [/unstore_unit]

    {CLEAR_VARIABLE FLOATING_TEXT_temp}
#enddef

#define CAPTURE_FILTERED_VILLAGES_COPY SIDE FILTER
    # Change ownership of villages matching the specified location filter.
    [store_locations]
        {FILTER}
        variable=temp_target_villages
    [/store_locations]

    {FOREACH temp_target_villages i}
        [capture_village]
            side={SIDE}
            x,y=$temp_target_villages[$i].x,$temp_target_villages[$i].y
        [/capture_village]
    {NEXT i}

    {CLEAR_VARIABLE temp_target_villages}
#enddef
